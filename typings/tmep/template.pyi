"""
This type stub file was generated by pyright.
"""

"""This file originates from the file `beets/util/functemplate.py
<https://raw.githubusercontent.com/beetbox/beets/master/beets/util/functemplate.py>`_
of the `beets project <http://beets.io>`_.

This module implements a string formatter based on the standard PEP
292 string.Template class extended with function calls. Variables, as
with string.Template, are indicated with $ and functions are delimited
with %.

This module assumes that everything is Unicode: the template and the
substitution values. Bytestrings are not supported. Also, the templates
always behave like the ``safe_substitute`` method in the standard
library: unknown symbols are left intact.

This is sort of like a tiny, horrible degeneration of a real templating
engine like Jinja2 or Mustache.
"""
SYMBOL_DELIM = ...
FUNC_DELIM = ...
GROUP_OPEN = ...
GROUP_CLOSE = ...
ARG_SEP = ...
ESCAPE_CHAR = ...
VARIABLE_PREFIX = ...
FUNCTION_PREFIX = ...
class Environment:
    """Contains the values and functions to be substituted into a
    template.
    """
    def __init__(self, values, functions) -> None:
        ...
    


def ex_lvalue(name): # -> Name:
    """A variable load expression."""
    ...

def ex_rvalue(name): # -> Name:
    """A variable store expression."""
    ...

def ex_literal(val): # -> Name | Num | Str | NameConstant | Constant:
    """An int, float, long, bool, string, or None literal with the given
    value.
    """
    ...

def ex_varassign(name, expr): # -> Assign:
    """Assign an expression into a single variable. The expression may
    either be an `ast.expr` object or a value to be used as a literal.
    """
    ...

def ex_call(func, args): # -> Call:
    """A function-call expression with only positional parameters. The
    function may be an expression or the name of a function. Each
    argument may be an expression or a value to be used as a literal.
    """
    ...

def compile_func(arg_names, statements, name=..., debug=...):
    """Compile a list of statements as the body of a function and return
    the resulting Python function. If `debug`, then print out the
    bytecode of the compiled function.
    """
    ...

class Symbol:
    """A variable-substitution symbol in a template."""
    def __init__(self, ident, original) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def evaluate(self, env):
        """Evaluate the symbol in the environment, returning a Unicode
        string.
        """
        ...
    
    def translate(self): # -> tuple[list[Name], set[Unknown], set[Unknown]]:
        """Compile the variable lookup."""
        ...
    


class Call:
    """A function call in a template."""
    def __init__(self, ident, args, original) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def evaluate(self, env): # -> str | Unknown:
        """Evaluate the function call in the environment, returning a
        Unicode string.
        """
        ...
    
    def translate(self): # -> tuple[list[Call], set[Unknown], set[Unknown]]:
        """Compile the function call."""
        ...
    


class Expression:
    """Top-level template construct: contains a list of text blobs,
    Symbols, and Calls.
    """
    def __init__(self, parts) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def evaluate(self, env): # -> str:
        """Evaluate the entire expression in the environment, returning
        a Unicode string.
        """
        ...
    
    def translate(self): # -> tuple[list[Unknown], set[Unknown], set[Unknown]]:
        """Compile the expression to a list of Python AST expressions, a
        set of variable names used, and a set of function names.
        """
        ...
    


class ParseError(Exception):
    ...


class Parser:
    """Parses a template expression string. Instantiate the class with
    the template source and call ``parse_expression``. The ``pos`` field
    will indicate the character after the expression finished and
    ``parts`` will contain a list of Unicode strings, Symbols, and Calls
    reflecting the concatenated portions of the expression.

    This is a terrible, ad-hoc parser implementation based on a
    left-to-right scan with no lexing step to speak of; it's probably
    both inefficient and incorrect. Maybe this should eventually be
    replaced with a real, accepted parsing technique (PEG, parser
    generator, etc.).
    """
    def __init__(self, string, in_argument=...) -> None:
        """ Create a new parser.
        :param in_arguments: boolean that indicates the parser is to be
        used for parsing function arguments, ie. considering commas
        (`ARG_SEP`) a special character
        """
        ...
    
    special_chars = ...
    special_char_re = ...
    escapable_chars = ...
    terminator_chars = ...
    def parse_expression(self): # -> None:
        """Parse a template expression starting at ``pos``. Resulting
        components (Unicode strings, Symbols, and Calls) are added to
        the ``parts`` field, a list.  The ``pos`` field is updated to be
        the next character after the expression.
        """
        ...
    
    def parse_symbol(self): # -> None:
        """Parse a variable reference (like ``$foo`` or ``${foo}``)
        starting at ``pos``. Possibly appends a Symbol object (or,
        failing that, text) to the ``parts`` field and updates ``pos``.
        The character at ``pos`` must, as a precondition, be ``$``.
        """
        ...
    
    def parse_call(self): # -> None:
        """Parse a function call (like ``%foo{bar,baz}``) starting at
        ``pos``.  Possibly appends a Call object to ``parts`` and update
        ``pos``. The character at ``pos`` must be ``%``.
        """
        ...
    
    def parse_argument_list(self): # -> list[Unknown]:
        """Parse a list of arguments starting at ``pos``, returning a
        list of Expression objects. Does not modify ``parts``. Should
        leave ``pos`` pointing to a } character or the end of the
        string.
        """
        ...
    


def cached(func): # -> _lru_cache_wrapper[Unknown]:
    """Like the `functools.lru_cache` decorator, but works (as a no-op)
    on Python < 3.2.
    """
    ...

@cached
def template(fmt): # -> Template:
    ...

class Template:
    """A string template, including text, Symbols, and Calls.
    """
    def __init__(self, template) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def interpret(self, values=..., functions=...): # -> str:
        """Like `substitute`, but forces the interpreter (rather than
        the compiled version) to be used. The interpreter includes
        exception-handling code for missing variables and buggy template
        functions but is much slower.
        """
        ...
    
    def substitute(self, values=..., functions=...): # -> str:
        """Evaluate the template given the values and functions.
        """
        ...
    
    def translate(self): # -> (values: Unknown = {}, functions: Unknown = {}) -> str:
        """Compile the template to a Python function."""
        ...
    


if __name__ == '__main__':
    _tmpl = ...
    _vars = ...
    _funcs = ...
    interp_time = ...
    comp_time = ...
