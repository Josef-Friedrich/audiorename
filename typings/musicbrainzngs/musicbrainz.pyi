"""
This type stub file was generated by pyright.
"""
import xml.etree.ElementTree as etree
from urllib.error import HTTPError

from musicbrainzngs import compat

_version = ...
_log = ...
LUCENE_SPECIAL = ...
RELATABLE_TYPES = ...
RELATION_INCLUDES = ...
TAG_INCLUDES = ...
RATING_INCLUDES = ...
VALID_INCLUDES = ...
VALID_BROWSE_INCLUDES = ...
VALID_RELEASE_TYPES = ...
VALID_RELEASE_STATUSES = ...
VALID_SEARCH_FIELDS = ...

class AUTH_YES: ...
class AUTH_NO: ...
class AUTH_IFSET: ...

class MusicBrainzError(Exception):
    """Base class for all exceptions related to MusicBrainz."""

    ...

class UsageError(MusicBrainzError):
    """Error related to misuse of the module API."""

    ...

class InvalidSearchFieldError(UsageError): ...

class InvalidIncludeError(UsageError):
    def __init__(self, msg=..., reason=...) -> None: ...
    def __str__(self) -> str: ...

class InvalidFilterError(UsageError):
    def __init__(self, msg=..., reason=...) -> None: ...
    def __str__(self) -> str: ...

class WebServiceError(MusicBrainzError):
    """Error related to MusicBrainz API requests."""

    cause: HTTPError

    def __init__(self, message: str = ..., cause: HTTPError = ...) -> None:
        """Pass ``cause`` if this exception was caused by another
        exception.
        """
    def __str__(self) -> str: ...

class NetworkError(WebServiceError):
    """Problem communicating with the MB server."""

    ...

class ResponseError(WebServiceError):
    """Bad response sent by the MB server."""

class AuthenticationError(WebServiceError):
    """Received a HTTP 401 response while accessing a protected resource."""

    ...

user = ...
hostname = ...
https = ...
_client = ...
_useragent = ...

def auth(u, p):  # -> None:
    """Set the username and password to be used in subsequent queries to
    the MusicBrainz XML API that require authentication.
    """
    ...

def set_useragent(app: str, version: str, contact: str = ...) -> None:
    """Set the User-Agent to be used for requests to the MusicBrainz webservice.
    This must be set before requests are made."""
    ...

def set_hostname(new_hostname, use_https=...):  # -> None:
    """Set the hostname for MusicBrainz webservice requests.
    Defaults to 'musicbrainz.org', accessing over https.
    For backwards compatibility, `use_https` is False by default.

    :param str new_hostname: The hostname (and port) of the MusicBrainz server to connect to
    :param bool use_https: `True` if the host should be accessed using https. Default is `False`

    Specify a non-standard port by adding it to the hostname,
    for example 'localhost:8000'."""
    ...

limit_interval = ...
limit_requests = ...
do_rate_limit = ...

def set_rate_limit(limit_or_interval=..., new_requests=...):  # -> None:
    """Sets the rate limiting behavior of the module. Must be invoked
    before the first Web service call.
    If the `limit_or_interval` parameter is set to False then
    rate limiting will be disabled. If it is a number then only
    a set number of requests (`new_requests`) will be made per
    given interval (`limit_or_interval`).
    """
    ...

class _rate_limit:
    """A decorator that limits the rate at which the function may be
    called. The rate is controlled by the `limit_interval` and
    `limit_requests` global variables.  The limiting is thread-safe;
    only one thread may be in the function at a time (acts like a
    monitor in this sense). The globals must be set before the first
    call to the limited function.
    """

    def __init__(self, fun) -> None: ...
    def __call__(self, *args, **kwargs): ...

class _RedirectPasswordMgr(compat.HTTPPasswordMgr):
    def __init__(self) -> None: ...
    def find_user_password(self, realm, uri): ...
    def add_password(self, realm, uri, username, password): ...

class _DigestAuthHandler(compat.HTTPDigestAuthHandler):
    def get_authorization(self, req, chal): ...
    def get_algorithm_impls(self, algorithm): ...

class _MusicbrainzHttpRequest(compat.Request):
    """A custom request handler that allows DELETE and PUT"""

    def __init__(self, method, url, data=...) -> None: ...
    def get_method(self): ...

if hasattr(etree, "ParseError"):
    ETREE_EXCEPTIONS = ...
else:
    ETREE_EXCEPTIONS = ...

def mb_parser_null(resp):
    """Return the raw response (XML)"""
    ...

def mb_parser_xml(resp):  # -> dict[Unknown, Unknown]:
    """Return a Python dict representing the XML response"""
    ...

parser_fun = ...
ws_format = ...

def set_parser(new_parser_fun=...):  # -> None:
    """Sets the function used to parse the response from the
    MusicBrainz web service.

    If no parser is given, the parser is reset to the default parser
    :func:`mb_parser_xml`.
    """
    ...

def set_format(fmt=...):  # -> None:
    """Sets the format that should be returned by the Web Service.
    The server currently supports `xml` and `json`.

    This method will set a default parser for the specified format,
    but you can modify it with :func:`set_parser`.

    .. warning:: The json format used by the server is different from
        the json format returned by the `musicbrainzngs` internal parser
        when using the `xml` format! This format may change at any time.
    """
    ...

@_docstring_get("area")
def get_area_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the area with the MusicBrainz `id` as a dict with an 'area' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("artist")
def get_artist_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the artist with the MusicBrainz `id` as a dict with an 'artist' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("instrument")
def get_instrument_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the instrument with the MusicBrainz `id` as a dict with an 'artist' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("label")
def get_label_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the label with the MusicBrainz `id` as a dict with a 'label' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("place")
def get_place_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the place with the MusicBrainz `id` as a dict with an 'place' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("event")
def get_event_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the event with the MusicBrainz `id` as a dict with an 'event' key.

    The event dict has the following keys:
    `id`, `type`, `name`, `time`, `disambiguation` and `life-span`.

    *Available includes*: {includes}"""
    ...

@_docstring_get("recording")
def get_recording_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the recording with the MusicBrainz `id` as a dict
    with a 'recording' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("release")
def get_release_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the release with the MusicBrainz `id` as a dict with a 'release' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("release-group")
def get_release_group_by_id(id, includes=..., release_status=..., release_type=...):
    """Get the release group with the MusicBrainz `id` as a dict
    with a 'release-group' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("series")
def get_series_by_id(id, includes=...):
    """Get the series with the MusicBrainz `id` as a dict with a 'series' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("work")
def get_work_by_id(id, includes=...):
    """Get the work with the MusicBrainz `id` as a dict with a 'work' key.

    *Available includes*: {includes}"""
    ...

@_docstring_get("url")
def get_url_by_id(id, includes=...):
    """Get the url with the MusicBrainz `id` as a dict with a 'url' key.

    *Available includes*: {includes}"""
    ...

@_docstring_search("annotation")
def search_annotations(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for annotations and return a dict with an 'annotation-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("area")
def search_areas(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for areas and return a dict with an 'area-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("artist")
def search_artists(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for artists and return a dict with an 'artist-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("event")
def search_events(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for events and return a dict with an 'event-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("instrument")
def search_instruments(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for instruments and return a dict with a 'instrument-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("label")
def search_labels(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for labels and return a dict with a 'label-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("place")
def search_places(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for places and return a dict with a 'place-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("recording")
def search_recordings(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for recordings and return a dict with a 'recording-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("release")
def search_releases(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for recordings and return a dict with a 'recording-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("release-group")
def search_release_groups(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for release groups and return a dict
    with a 'release-group-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("series")
def search_series(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for series and return a dict with a 'series-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_search("work")
def search_works(query=..., limit=..., offset=..., strict=..., **fields):
    """Search for works and return a dict with a 'work-list' key.

    *Available search fields*: {fields}"""
    ...

@_docstring_get("discid")
def get_releases_by_discid(id, includes=..., toc=..., cdstubs=..., media_format=...):
    """Search for releases with a :musicbrainz:`Disc ID` or table of contents.

    When a `toc` is provided and no release with the disc ID is found,
    a fuzzy search by the toc is done.
    The `toc` should have to same format as :attr:`discid.Disc.toc_string`.
    When a `toc` is provided, the format of the discid itself is not
    checked server-side, so any value may be passed if searching by only
    `toc` is desired.

    If no toc matches in musicbrainz but a :musicbrainz:`CD Stub` does,
    the CD Stub will be returned. Prevent this from happening by
    passing `cdstubs=False`.

    By default only results that match a format that allows discids
    (e.g. CD) are included. To include all media formats, pass
    `media_format='all'`.

    The result is a dict with either a 'disc' , a 'cdstub' key
    or a 'release-list' (fuzzy match with TOC).
    A 'disc' has an 'offset-count', an 'offset-list' and a 'release-list'.
    A 'cdstub' key has direct 'artist' and 'title' keys.

    *Available includes*: {includes}"""
    ...

@_docstring_get("recording")
def get_recordings_by_isrc(isrc, includes=..., release_status=..., release_type=...):
    """Search for recordings with an :musicbrainz:`ISRC`.
    The result is a dict with an 'isrc' key,
    which again includes a 'recording-list'.

    *Available includes*: {includes}"""
    ...

@_docstring_get("work")
def get_works_by_iswc(iswc, includes=...):
    """Search for works with an :musicbrainz:`ISWC`.
    The result is a dict with a`work-list`.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("artist")
def browse_artists(
    recording=...,
    release=...,
    release_group=...,
    work=...,
    includes=...,
    limit=...,
    offset=...,
):
    """Get all artists linked to a recording, a release or a release group.
    You need to give one MusicBrainz ID.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("event")
def browse_events(area=..., artist=..., place=..., includes=..., limit=..., offset=...):
    """Get all events linked to a area, a artist or a place.
    You need to give one MusicBrainz ID.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("label")
def browse_labels(release=..., includes=..., limit=..., offset=...):
    """Get all labels linked to a relase. You need to give a MusicBrainz ID.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("place")
def browse_places(area=..., includes=..., limit=..., offset=...):
    """Get all places linked to an area. You need to give a MusicBrainz ID.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("recording")
def browse_recordings(artist=..., release=..., includes=..., limit=..., offset=...):
    """Get all recordings linked to an artist or a release.
    You need to give one MusicBrainz ID.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("release")
def browse_releases(
    artist=...,
    track_artist=...,
    label=...,
    recording=...,
    release_group=...,
    release_status=...,
    release_type=...,
    includes=...,
    limit=...,
    offset=...,
):
    """Get all releases linked to an artist, a label, a recording
    or a release group. You need to give one MusicBrainz ID.

    You can also browse by `track_artist`, which gives all releases where some
    tracks are attributed to that artist, but not the whole release.

    You can filter by :data:`musicbrainz.VALID_RELEASE_TYPES` or
    :data:`musicbrainz.VALID_RELEASE_STATUSES`.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("release-group")
def browse_release_groups(
    artist=..., release=..., release_type=..., includes=..., limit=..., offset=...
):
    """Get all release groups linked to an artist or a release.
    You need to give one MusicBrainz ID.

    You can filter by :data:`musicbrainz.VALID_RELEASE_TYPES`.

    *Available includes*: {includes}"""
    ...

@_docstring_browse("url")
def browse_urls(resource=..., includes=..., limit=..., offset=...):
    """Get urls by actual URL string.
    You need to give a URL string as 'resource'

    *Available includes*: {includes}"""
    ...

@_docstring_browse("work")
def browse_works(artist=..., includes=..., limit=..., offset=...):
    """Get all works linked to an artist

    *Available includes*: {includes}"""
    ...

def get_collections():
    """List the collections for the currently :func:`authenticated <auth>` user
    as a dict with a 'collection-list' key."""
    ...

def get_artists_in_collection(collection, limit=..., offset=...):
    """List the artists in a collection.
    Returns a dict with a 'collection' key, which again has a 'artist-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def get_releases_in_collection(collection, limit=..., offset=...):
    """List the releases in a collection.
    Returns a dict with a 'collection' key, which again has a 'release-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def get_events_in_collection(collection, limit=..., offset=...):
    """List the events in a collection.
    Returns a dict with a 'collection' key, which again has a 'event-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def get_places_in_collection(collection, limit=..., offset=...):
    """List the places in a collection.
    Returns a dict with a 'collection' key, which again has a 'place-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def get_recordings_in_collection(collection, limit=..., offset=...):
    """List the recordings in a collection.
    Returns a dict with a 'collection' key, which again has a 'recording-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def get_works_in_collection(collection, limit=..., offset=...):
    """List the works in a collection.
    Returns a dict with a 'collection' key, which again has a 'work-list'.

    See `Browsing`_ for how to use `limit` and `offset`.
    """
    ...

def submit_barcodes(release_barcode):
    """Submits a set of {release_id1: barcode, ...}"""
    ...

def submit_isrcs(recording_isrcs):
    """Submit ISRCs.
    Submits a set of {recording-id1: [isrc1, ...], ...}
    or {recording_id1: isrc, ...}.
    """
    ...

def submit_tags(**kwargs):
    """Submit user tags.
    Takes parameters named e.g. 'artist_tags', 'recording_tags', etc.,
    and of the form:
    {entity_id1: [tag1, ...], ...}
    If you only have one tag for an entity you can use a string instead
    of a list.

    The user's tags for each entity will be set to that list, adding or
    removing tags as necessary. Submitting an empty list for an entity
    will remove all tags for that entity by the user.
    """
    ...

def submit_ratings(**kwargs):
    """Submit user ratings.
    Takes parameters named e.g. 'artist_ratings', 'recording_ratings', etc.,
    and of the form:
    {entity_id1: rating, ...}

    Ratings are numbers from 0-100, at intervals of 20 (20 per 'star').
    Submitting a rating of 0 will remove the user's rating.
    """
    ...

def add_releases_to_collection(collection, releases=...):
    """Add releases to a collection.
    Collection and releases should be identified by their MBIDs
    """
    ...

def remove_releases_from_collection(collection, releases=...):
    """Remove releases from a collection.
    Collection and releases should be identified by their MBIDs
    """
    ...
