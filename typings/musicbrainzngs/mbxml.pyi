"""
This type stub file was generated by pyright.
"""

def fixtag(tag, namespaces): ...

NS_MAP = ...
_log = ...

def get_error_message(error):  # -> list[Unknown] | None:
    """Given an error XML message from the webservice containing
    <error><text>x</text><text>y</text></error>, return a list
    of [x, y]"""
    ...

def make_artist_credit(artists): ...
def parse_elements(valid_els, inner_els, element):
    """Extract single level subelements from an element.
    For example, given the element:
    <element>
        <subelement>Text</subelement>
    </element>
    and a list valid_els that contains "subelement",
    return a dict {'subelement': 'Text'}

    Delegate the parsing of multi-level subelements to another function.
    For example, given the element:
    <element>
        <subelement>
            <a>Foo</a><b>Bar</b>
        </subelement>
    </element>
    and a dictionary {'subelement': parse_subelement},
    call parse_subelement(<subelement>) and
    return a dict {'subelement': <result>}
    if parse_subelement returns a tuple of the form
    (True, {'subelement-key': <result>})
    then merge the second element of the tuple into the
    result (which may have a key other than 'subelement' or
    more than 1 key)
    """
    ...

def parse_attributes(attributes, element):  # -> dict[Unknown, Unknown]:
    """Extract attributes from an element.
    For example, given the element:
    <element type="Group" />
    and a list attributes that contains "type",
    return a dict {'type': 'Group'}
    """
    ...

def parse_message(message): ...
def parse_response_message(message): ...
def parse_collection_list(cl): ...
def parse_collection(collection): ...
def parse_annotation_list(al): ...
def parse_annotation(annotation): ...
def parse_lifespan(lifespan): ...
def parse_area_list(al): ...
def parse_area(area): ...
def parse_artist_list(al): ...
def parse_artist(artist): ...
def parse_coordinates(c): ...
def parse_place_list(pl): ...
def parse_place(place): ...
def parse_event_list(el): ...
def parse_event(event): ...
def parse_instrument(instrument): ...
def parse_label_list(ll): ...
def parse_label(label): ...
def parse_relation_target(tgt): ...
def parse_relation_list(rl): ...
def parse_relation(relation): ...
def parse_relation_attribute_list(attributelist): ...
def parse_relation_attribute_element(element): ...
def parse_release(release): ...
def parse_medium_list(ml):  # -> tuple[Literal[True], dict[str, list[Unknown]]]:
    """medium-list results from search have an additional
    <track-count> element containing the number of tracks
    over all mediums. Optionally add this"""
    ...

def parse_release_event_list(rel): ...
def parse_release_event(event): ...
def parse_medium(medium): ...
def parse_disc_list(dl): ...
def parse_text_representation(textr): ...
def parse_release_group(rg): ...
def parse_recording(recording): ...
def parse_series_list(sl): ...
def parse_series(series): ...
def parse_external_id_list(pl): ...
def parse_element_list(el): ...
def parse_work_list(wl): ...
def parse_work(work): ...
def parse_work_attribute_list(wal): ...
def parse_work_attribute(wa): ...
def parse_url_list(ul): ...
def parse_url(url): ...
def parse_disc(disc): ...
def parse_cdstub(cdstub): ...
def parse_offset_list(ol): ...
def parse_instrument_list(rl): ...
def parse_release_list(rl): ...
def parse_release_group_list(rgl): ...
def parse_isrc(isrc): ...
def parse_recording_list(recs): ...
def parse_artist_credit(ac): ...
def parse_name_credit(nc): ...
def parse_label_info_list(lil): ...
def parse_label_info(li): ...
def parse_track_list(tl): ...
def parse_track(track): ...
def parse_tag_list(tl): ...
def parse_tag(tag): ...
def parse_rating(rating): ...
def parse_alias_list(al): ...
def parse_alias(alias): ...
def parse_caa(caa_element): ...
def make_barcode_request(release2barcode): ...
def make_tag_request(**kwargs): ...
def make_rating_request(**kwargs): ...
def make_isrc_request(recording2isrcs): ...
